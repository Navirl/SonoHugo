[UnityのCameraが使う３つの座標系 - テラシュールブログ](https://tsubakit1.hateblo.jp/entry/2014/07/22/010739)

## Renderer.isVisible
**レンダーコンポーネントのメソッド。** 返り値はbool。
特性上、GetComponent\<Render\>()が必要になる。つまりRenderer必須。
**オブジェクトの後ろに隠れていようと、シーンビューのカメラだろうとtrueを返してくる。**

## OnBecameVisible、OnBecameInVisible
**MonoBehaiviourのメソッド。**  それぞれ表示されたとき、表示されなくなったときに**一度だけ**呼ばれる。
RendererさえAttachされていればOK。
**オブジェクトの後ろに隠れていようと、シーンビューのカメラだろうとtrueを返してくる。** 逆に言うと、どのカメラにも映っていないときだけFalseになる。

## OnWillRenderObject
**MonoBehaiviourのメソッド。**  **各カメラごとに呼ばれる**。この中でのみ**Camera.currentで映っているカメラが取得できる。**
RendererさえAttachされていればOK。
上記の特性のため、**カメラごとに処理を分離できる。**

## Camera.ViewportPointToRay()
**カメラのメソッド。** 引数はビューポート座標のVector3で、**返り値はRay。**
**カメラと引数に渡された座標を繋ぐ方向にRay(Vector)を飛ばす**のが目的であり、画面外判定に使うなら**何もない可能性がある場合には使えない。** （もちろん、Colliderがないと意味なし）
また、ヒットしたかの判定にRaycastHit型の値が必要だったりする。RayとRaycastをPhysics.Raycast関数につっこめばBoolが返ってくる。**（ついでに、Raycastにoutキーワードをつけると、Raycastにヒットした位置を詰めて一緒に返してくれる）** 公式で説明されている使用法はオブジェクトへの一直線ズーム。
記事で説明されているのは、左下(0,0)と右上(1,1)にRayを飛ばし、当たったポイントと画面外判定したい対象の位置を比較するという手法。



## Camera.ViewportToWorldPoint()
**カメラのメソッド。** 引数はビューポート座標のVector3で、引数に渡すZの値はカメラと面の間の距離。返り値は引数のワールド座標。
つまり**「カメラと一定距離離れた地点でカメラに映る範囲」** が返ってくる。
特性上、**カメラと水平な面の座標しか取れない。** そのため画面外判定に使えるのは「カメラとステージが水平で、ステージが真っ平らな場合」くらい。

## Camera.WorldToViewportPoint()
**カメラのメソッド。** 引数はワールド座標のVector3で、返り値はビューポート座標。数値が(0,0)~(1,1)の間にあれば画面内であるといえる。

## Collier
画面周囲をColliderで、あるいは画面全体を覆うColliderで判定する方法。
単純で楽そうに見えて、**スマホアプリだと解像度の差によりColliderがずれるため使えない**手。

[【Unity】オブジェクトが画面外かどうかを判定する方法(まとめ) \| tama-lab](https://tama-lab.net/2018/08/%E3%80%90unity%E3%80%91%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%8C%E7%94%BB%E9%9D%A2%E5%A4%96%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%82%92%E5%88%A4%E5%AE%9A%E3%81%99%E3%82%8B/)