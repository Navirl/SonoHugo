---
date: 2021-08-13 11:19:11
tags:
 - Program
---
pythonでやります。

## AND, OR, XOR, NOT
| AND   | 掛け算 | 結果 |
|-------|--------|:----:|
| 0 & 0 | 0 * 0  |   0  |
| 0 & 1 | 0 * 1  |   0  |
| 1 & 0 | 1 * 0  |   0  |
| 1 & 1 | 1 * 1  |   1  |

| OR     | 足し算 | 結果 |
|--------|--------|------|
| 0 \| 0 | 0 + 0  | 0    |
| 0 \| 1 | 0 + 1  | 1    |
| 1 \| 0 | 1 + 0  | 1    |
| 1 \| 1 | 1 + 1  | 2→1  |

| XOR   | 足し算 | 結果 |
|-------|--------|------|
| 0 ^ 0 | 0 + 0  | 0    |
| 0 ^ 1 | 0 + 1  | 1    |
| 1 ^ 0 | 1 + 0  | 1    |
| 1 ^ 1 | 1 + 1  | 2→0  |

| NOT | 結果 |
| --- |:----:|
| 1   | 0001 |
| ~1  | 1110 |


大体はこれらのビット計算の組み合わせで表現する。

## 基数、補数、減基数の補数
基数は**ある数n**のこと。
仮にここでは1とする。

補数は**基数に対して足し合わせた時に桁が一つ上がる最小の数。**
1についての補数は9であり99ではない。

減基数の補数は**補数から1を引いた数。**
1についての8のこと。

10進数の場合、補数のことを10の補数、減基数の補数を9の補数と呼ぶ。

## 2の補数
2進数における補数のこと。
ビットを反転した後、1を足すと作れる。

## 本題
補数を足した後、最大桁数にある1を消せば引き算したのと同じになる。
たとえば`42 - 28 = 14`を`42 + 72`とすると答えは`114`になり、1を消すと等しくなることがわかる。

これをコンピューターにやらせるために、2の補数を作る必要がある。
（素直に引き算するより早いらしい）

```python
print(bin(42-24))
#0b10010

print(bin(24))
#0b11000

print(bin(~0b11000))
#-0b11001

print(bin(~0b11000&0b11111))
#0b111

print(bin((~0b11000&0b11111)+1))
#0b1000
#0b11000と足すと一桁上がって0b100000になる、つまり0b11000の2の補数を表している

print(bin(0b101010+((~0b11000&0b11111)+1)))
#0b110010
#頭の1を消すと最初と等しくなる
```

ただ単に~をつけるだけでは、標準だと0で埋められてる上の桁も1になり、マイナス扱いになってしまう。
そこで**「基数の桁数と同じ数だけ1を並べた数」でAND演算** して、必要な部分を取り出す。
そのあと1を足せば2の補数ができるので、あとは普通に足し算。
一瞬混乱するけど、最大桁数の1云々は2進数での話であって、10進数に直した時の最大桁数は関係ない。

[2の補数とは？2の補数の計算方法と表現範囲をわかりやすく解説！1の補数との違いは？C言語での補数計算プログラムもチェック \| A-STAR（エースター）](https://agency-star.co.jp/column/2-complement/)

[Python ビット演算 超入門 - Qiita](https://qiita.com/7shi/items/41d262ca11ea16d85abc)
